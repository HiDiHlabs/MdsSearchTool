/*
 * Copyright (c) 2018. dkfz
 *
 * Distributed under the MIT License (license terms are at https://github.com/eilslabs/MdsSearchTool/blob/master/LICENSE).
 *
 *
 */

package de.utils.decryption;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.Charset;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.crypto.Cipher;
import org.apache.commons.codec.binary.Base64;

/**
 * Handles decryption of export ids.
 * 
 * Utility class for decrypting export ids that were created by a Mainzelliste instance
 * using the public key of the receiver.
 * 
 * @author Andreas Borg
 * @version 0.3
 */
public class IdDecryptor {
    
    /**
     * Initialize an IdDecryptor.
     * 
     * The private key for encryption must reside in a file in DER format. 
     * It can be generated by the following OpenSSL commands:
     * {@code 
     *   openssl genrsa -out private-key.pem 2048
     *   openssl pkcs8 -topk8 -inform PEM -outform DER -in private-key.pem -out private-key.der -nocrypt
     *   openssl rsa -in private-key.pem -pubout -outform DER -out public-key.der
     *  }
     *  
     * @param privateKeyFileName Path to file with private key.
     * @throws IOException If the key file could not be read.
     * @throws CryptoException If the encryption algorithm could not be initialized, for example due to an invalid key.
     * 
     */ 
    public IdDecryptor(String privateKeyFileName, int cacheSize) throws IOException, CryptoException {
        File privateKeyFile = new File(privateKeyFileName);
        if (!privateKeyFile.exists())
            throw new FileNotFoundException(String.format("Could not find key file %s", privateKeyFileName));
        FileInputStream s = new FileInputStream(privateKeyFile);
        byte bytes[] = new byte[(int) privateKeyFile.length()];
        s.read(bytes);
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(bytes);
        try {
            KeyFactory kf = KeyFactory.getInstance("RSA");
            decryptKey = kf.generatePrivate(spec);
            decryptor = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
            decryptor.init(Cipher.DECRYPT_MODE, decryptKey);
        } catch (Exception e) {
            throw new CryptoException(e);
        }
        this.cacheSize = cacheSize;
        this.cache = new IdCache();
    }

    /**
     * Decrypts an id string.
     * @param input Encrypted id as URL safe Base64 encoded byte array.
     * 
     * @throws CryptoException If an error in the decryption algorithm occurs.
     */
    public String decrypt(String input) throws CryptoException {
        String output = cache.get(input);
        if (output != null)
            return output;

        // else
        byte inputBytes[] = base64Codec.decode(input);
        
        try {
            byte outputBytes[] = decryptor.doFinal(inputBytes);
            output = new String(outputBytes, ENCODING);
            cache.put(input, output);
            
            return output;
        } catch (Exception e) {
            throw new CryptoException(e);
        }
        
    }
    
    
    /**
     * Exception for errors within the decryption algorithm.
     * The exact cause can be retreived by {@code getCause()} and is usually one of the following:
     * <ul>
     *  <li> NoSuchAlgorithmException </li>
     *  <li> InvalidKeySpecException </li>
     *  <li> NoSuchPaddingException </li>
     *  <li> InvalidKeyException </li>
     *  <li> IllegalBlockSizeException </li>
     *  <li> BadPaddingException </li>
     * </ul>
     * @author Andreas Borg
     *
     */
    public class CryptoException extends Exception {
        public CryptoException(Throwable cause) {
            super("An error occured while initializing the encryption algorithm", cause);
        }
    }
    
    private PrivateKey decryptKey;
    private Cipher decryptor;
    private final int cacheSize;
    private IdCache cache;
    private static final Charset ENCODING = Charset.forName("UTF8");
    Base64 base64Codec = new Base64(true);


    /**
     * LRU cache via LinkedHashMap
     * @author Andreas Borg
     *
     */
    private class IdCache extends LinkedHashMap<String, String> {
        public IdCache() {
            /* 
             * add one because there are cacheSize + 1 elements temporarily
             * between adding element and removing old entries
             */
            super((int) (Math.ceil(cacheSize + 1 / 0.75)), 0.75f, true);
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
            return size() > IdDecryptor.this.cacheSize;
        }
    }
}

